---
title: "Generating Test Plans with TestDriver.ai"
sidebarTitle: "Generating Tests"
description: "Learn how to generate test plans locally with TestDriver.ai and integrate them into your testing workflow."
---

# Running Locally Generated Test Plans with TestDriver.ai and Managing Generated PRs

This guide explains how to use **TestDriver.ai** to generate test plans locally, commit them to your repository, and run them in parallel using GitHub Actions. Additionally, it covers how **TestDriver.ai** can automatically create **pull requests (PRs)** for test results, enabling collaboration and review.

---

## Workflow Overview

1. **Generate Test Plans Locally**: Use the `/generate` command to create test plans.
2. **Commit Test Plans to the Repository**: Add the generated files to your repository for version control.
3. **Run Tests in Parallel**: Use GitHub Actions to execute the committed test plans in parallel.
4. **Create PRs for Test Results**: Automatically generate PRs for test results, allowing teams to review and merge updates.

---

## Step 1: Generate Test Plans Locally

### Run `/generate` Locally

1. Open your terminal and navigate to your project directory.
2. Run the following command to start TestDriver.ai locally:


```bash
testdriverai
> /generate web 10

```

This will generate 10 test plans for your website or application.

---

### Save the Generated Files

TestDriver.ai will save the generated test plans as YAML files in the `testdriver/generate/` directory by default. For example:

```
testdriver/
├── generate/
│   ├── test_1.yml
│   ├── test_2.yml
│   ├── test_3.yml

```

---

### Commit the Files to Your Repository

1. Add the generated files to your Git repository:

```bash
git add testdriver/generate/
git commit -m "Add locally generated test plans"
git push origin main

```

---

## Step 2: Run Tests in Parallel Using GitHub Actions

### Workflow: **Run Locally Generated Tests**

This workflow dynamically discovers the committed test files and runs them in parallel.

#### Example Workflow: `.github/workflows/run-tests.yml`

```yaml
name: Run Locally Generated Test Plans

on:
  push:
    paths:
      - 'testdriver/generate/**'
  workflow_dispatch:

jobs:
  gather-test-files:
    name: Gather Test Files
    runs-on: ubuntu-latest
    outputs:
      test_files: ${{ steps.test_list.outputs.files }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v2

      - name: Find all test files
        id: test_list
        run: |
          FILES=$(ls ./testdriver/generate/*.yml)
          FILES_JSON=$(echo "$FILES" | jq -R -s -c 'split("\n")[:-1]')
          echo "::set-output name=files::$FILES_JSON"

  run-tests:
    name: Run Tests in Parallel
    needs: gather-test-files
    runs-on: ubuntu-latest
    strategy:
      matrix:
        test_file: ${{ fromJson(needs.gather-test-files.outputs.test_files) }}
      fail-fast: false
    steps:
      - name: Check out repository
        uses: actions/checkout@v2

      - name: Run TestDriver.ai
        uses: testdriverai/action@main
        with:
          key: ${{ secrets.TESTDRIVER_API_KEY }}
          prompt: |
            1. /run ${{ matrix.test_file }}
          create-pr: true
          pr-title: "TestDriver.ai / Test Results for ${{ matrix.test_file }}"
          pr-branch: testdriver/results-${{ matrix.test_file }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FORCE_COLOR: "3"

```


---

### Workflow Steps Explained

1. **Trigger on Push**:
- The workflow triggers whenever files in the `testdriver/generate/` directory are pushed to the repository.

2. **Gather Test Files**:
- The `gather-test-files` job collects all YAML files in the `testdriver/generate/` directory and outputs them as a JSON array.

3. **Run Tests in Parallel**:
- The `run-tests` job uses the matrix strategy to run each test file in parallel.

4. **Create PRs for Test Results**:
- For each test file, a new branch is created with the test results, and a PR is opened for review.

---

## Step 3: Generated PRs for Test Results

### How PRs Are Created

When the tests are executed, TestDriver.ai automatically:
1. Creates a new branch for each test result (e.g., `testdriver/results-test_1.yml`).
2. Commits the test results to the branch.
3. Opens a pull request with the test results for review.

---

### Example PR Details

#### PR Title:
`TestDriver.ai / Test Results for test_1.yml`

#### PR Description:


```
### Test Results for test_1.yml

**Test Summary**:
- ✅ Step 1: Opened the homepage.
- ✅ Step 2: Verified the login button is visible.
- ❌ Step 3: Failed to submit the login form.

**Details**:
- Error: The "Submit" button was not clickable.

Please review the test results and address any issues.

```

---

### Benefits of Generated PRs

1. **Collaboration**: Teams can review test results directly in GitHub and discuss issues in the PR comments.
2. **Traceability**: Each test result is tied to a specific branch and PR, making it easy to track changes.
3. **Continuous Improvement**: Failed tests can be addressed and merged back into the main branch after fixes.

---

## Example Output

### GitHub Actions Dashboard:
- ✅ **Run Tests in Parallel**: All tests passed.
- ❌ **Run Tests in Parallel**: 1 test failed. View logs for details.

### Pull Requests:
- **PR #123**: `TestDriver.ai / Test Results for test_1.yml`
- **PR #124**: `TestDriver.ai / Test Results for test_2.yml`

---

## Summary

1. **Generate Tests Locally**: Use the `/generate` command to create test plans.
2. **Commit and Run Tests**: Push the generated files to your repository and execute them in parallel.
3. **Review Generated PRs**: Collaborate on test results using automatically created pull requests.
4. **Merge Fixes**: Address issues and merge the PRs back into the main branch.

By leveraging TestDriver.ai's ability to generate and manage PRs, you can streamline your testing workflow and improve collaboration across your team.
