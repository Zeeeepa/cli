---
title: "Optimizing Performance in TestDriver"
sidebarTitle: "Performance Optimization"
description: "Optimizing Performance in TestDriver"
icon: "rabbit-running"
---

## Overview

Optimizing your TestDriver tests can significantly reduce execution time, ensuring faster feedback for developers and smoother CI/CD workflows. While TestDriver's AI-powered capabilities are robust, using them efficiently is key to achieving the best performance.

---

## Tips for improving performance

### 1. Use parallel testing

Parallel testing allows you to split your test actions into multiple files and run them simultaneously. This can drastically reduce the total runtime of your test suite.

#### How to implement parallel testing

- Divide your test steps into smaller, independent YAML files.
- Use a test matrix strategy to execute these files in parallel.

<Warning>
  The [`run`](/commands/run) command is used in your test files to run other
  test files. This is useful for breaking down large tests into smaller, more
  manageable pieces. To run multiple separate tests, use a test matrix strategy.
</Warning>

#### Example

```yaml .github/workflows/testdriver.yaml focus={3-9, 14}
run tests:
  name: Run tests in parallel
  strategy:
    matrix:
      test_file:
        - tests/login.yaml
        - tests/search.yaml
        - tests/cart.yaml
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run the tests
          run: npx testdriverai@latest run testdriver/${{ matrix.test_file }}
          env:
            FORCE_COLOR: 3
            TD_API_KEY: ${{ secrets.TD_API_KEY }}
            TD_WEBSITE: https://testdriver-sandbox.vercel.app
            TD_THIS_FILE: ${{ matrix.test }}
```

---

### 2. Use optimized matching methods

For actions like [`hover-text`](/commands/hover-text), [`wait-for-text`](/commands/wait-for-text), and [`scroll-until-text`](/commands/scroll-until-text), use the `turbo` matching method instead of `ai`. The `turbo` method uses text similarity to quickly compute the most relevant match, making it about 40% faster than the `ai` method.

#### Example

```yaml
command: [`hover-text`](/commands/hover-text)
text: Sign In
description: login button
action: click
method: turbo
```

<Note>
  `turbo` is the default method that is currently implemented. The other method
  being `ai`
</Note>

---

### 3. Use `async` asserts

The [`assert`](/commands/assert) command supports the `async: true` property, allowing you to create non-blocking assertions. This means your tests can continue running while the assertion is being validated, saving valuable time.

#### Example

```yaml
command: [`assert`](/commands/assert)
expect: The user is logged in
async: true
```

---

## Best practices

- **Minimize AI Matching**: Use AI-powered matching methods only when necessary. For common actions, rely on optimized methods like `turbo`.
- **Break Down Tests**: Split large, monolithic test files into smaller, focused tests to enable parallel execution.
- **Leverage Asynchronous Features**: Use `async` properties wherever possible to avoid blocking test execution.
- **Monitor Performance**: Regularly review test execution times and identify bottlenecks.

---

## Notes

- Optimizing performance not only saves time but also reduces resource usage, making your CI/CD pipelines more efficient.
- For large test suites, combining parallel testing with optimized matching methods can lead to significant time savings.
- Always balance performance optimizations with test reliability to ensure accurate results.
