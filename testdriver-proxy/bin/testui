#!/usr/bin/env node

const { spawn } = require('child_process');
const path = require('path');
const http = require('http');
const fs = require('fs');
const axios = require('axios');
const yaml = require('js-yaml');
const os = require('os');

const INSTALL_DIR = path.join(__dirname, '..');
const TEST_APP_DIR = path.join(INSTALL_DIR, 'tests', 'ui', 'test-app');
const SERVER_SCRIPT = path.join(INSTALL_DIR, 'server.js');
const TEMP_DIR = path.join(os.tmpdir(), 'testui-temp');

const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m'
};

function log(color, msg) {
  console.log(colors[color] + msg + colors.reset);
}

function parseArgs() {
  const args = process.argv.slice(2);
  const fullInput = args.join(' ');
  
  const parsed = {
    prompt: null,
    testFile: null,
    isUpgrade: false
  };

  // Check if input contains file path patterns
  const filePathRegex = /(?:upgrade|enhance|improve|modify)\s+([^\s]+\.ya?ml)/i;
  const standaloneFileRegex = /^([^\s]+\.ya?ml)$/;
  
  const upgradeMatch = fullInput.match(filePathRegex);
  const standaloneMatch = fullInput.match(standaloneFileRegex);
  
  if (upgradeMatch) {
    // Format: "upgrade /path/to/test.yaml to include robust testing"
    parsed.testFile = upgradeMatch[1];
    parsed.isUpgrade = true;
    // Extract the instruction part after the file path
    const afterFile = fullInput.substring(fullInput.indexOf(upgradeMatch[1]) + upgradeMatch[1].length).trim();
    parsed.prompt = afterFile || 'enhance with robust testing and error handling';
  } else if (standaloneMatch) {
    // Format: "/path/to/test.yaml" (just run the file)
    parsed.testFile = standaloneMatch[1];
    parsed.prompt = null;
  } else {
    // Everything else is a prompt
    parsed.prompt = fullInput;
  }

  return parsed;
}

function showHelp() {
  log('cyan', '\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  log('cyan', '‚ïë  TestUI - AI Agent Test Execution         ‚ïë');
  log('cyan', '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  
  console.log('TestUI uses natural language to generate and execute browser tests.\n');
  
  console.log('Usage:');
  console.log('  testui "natural language instructions"\n');
  
  console.log('Examples:\n');
  
  console.log('  üìù Generate & run new test:');
  console.log('  testui "go to google, search for analysis tools and get best UI tools"');
  console.log('  testui "test login on myapp.com with user@test.com"\n');
  
  console.log('  ‚¨ÜÔ∏è  Upgrade existing test:');
  console.log('  testui "upgrade /home/l/test.yaml to include robust testing"');
  console.log('  testui "enhance ./tests/login.yaml with error handling"\n');
  
  console.log('  ‚ñ∂Ô∏è  Run existing test file:');
  console.log('  testui "./tests/checkout.yaml"\n');
  
  console.log('How it works:');
  console.log('  --prompt: Sends context to AI (glm-4.5V)');
  console.log('            ‚Üí Generates YAML test');
  console.log('            ‚Üí Auto-runs the test');
  console.log('  --file:   Runs existing YAML directly');
  console.log('  Both:     AI enhances existing YAML with prompt context\n');
  
  console.log('Environment Variables:');
  console.log('  ANTHROPIC_API_KEY    - Your API key (required)');
  console.log('  TESTUI_PROXY_PORT    - Proxy server port (default: 9876)');
  console.log('  MODEL                - Override model (default: glm-4.5V)\n');
  
  console.log('Note: URLs can be included directly in prompts!');
  console.log('      No separate --app flag needed.\n');
  
  process.exit(0);
}

function checkPort(port) {
  return new Promise((resolve) => {
    const server = http.createServer();
    server.once('error', () => resolve(true));
    server.once('listening', () => {
      server.close();
      resolve(false);
    });
    server.listen(port);
  });
}

async function generateYAMLFromPrompt(prompt, proxyPort, existingYamlPath = null, isUpgrade = false) {
  log('cyan', '\nü§ñ Generating test YAML from prompt...');
  log('magenta', `   üìù "${prompt}"\n`);
  
  let existingYamlContent = null;
  if (existingYamlPath) {
    if (fs.existsSync(existingYamlPath)) {
      log('blue', `   üìÑ ${isUpgrade ? 'Upgrading' : 'Enhancing'} existing YAML: ${existingYamlPath}`);
      existingYamlContent = fs.readFileSync(existingYamlPath, 'utf8');
    } else {
      log('yellow', `   ‚ö†Ô∏è  File not found: ${existingYamlPath}`);
      log('yellow', '   Creating new test based on your instructions...\n');
      existingYamlPath = null;
    }
  }
  
  try {
    let contextPrompt;
    if (existingYamlContent) {
      // Smart upgrade prompt for existing files
      contextPrompt = `You are upgrading an existing TestDriver YAML test file.

USER REQUEST: ${prompt}

EXISTING TEST FILE:
\`\`\`yaml
${existingYamlContent}
\`\`\`

INSTRUCTIONS:
1. Analyze the existing test structure carefully
2. Keep all existing test steps unless they conflict with the upgrade request
3. Add new steps or enhance existing ones based on the request
4. If the request says "robust testing", add:
   - Error handling steps
   - Validation assertions
   - Edge case testing
   - Wait steps for stability
5. Maintain the existing test flow and structure
6. Output ONLY the complete upgraded YAML test (all steps, not just new ones)
7. Use proper TestDriver YAML format

Generate the COMPLETE upgraded test:`;
    } else {
      contextPrompt = prompt;
    }
      
    const response = await axios.post(`http://localhost:${proxyPort}/api/v1/testdriver/input`, {
      input: contextPrompt,
      screenshot: '',
      mousePosition: { x: 0, y: 0 },
      activeWindow: 'TestUI',
      stream: false
    }, {
      timeout: 60000,  // Increased timeout for complex upgrades
      headers: { 'Content-Type': 'application/json' }
    });
    
    if (response.data && response.data.markdown) {
      // Extract YAML from markdown code block
      const markdown = response.data.markdown;
      const yamlMatch = markdown.match(/```yaml\n([\s\S]*?)\n```/);
      
      if (!yamlMatch) {
        throw new Error('No YAML code block found in response');
      }
      
      const yamlSteps = yamlMatch[1];
      
      // Wrap in proper TestDriver format
      const yamlContent = `version: "1"
name: ${existingYamlPath ? `Enhanced Test: ${path.basename(existingYamlPath)}` : 'Generated Test from Prompt'}
description: ${prompt}
steps:
${yamlSteps}`;
      
      // Save to temp file
      if (!fs.existsSync(TEMP_DIR)) {
        fs.mkdirSync(TEMP_DIR, { recursive: true });
      }
      
      const tempFile = path.join(TEMP_DIR, `test-${Date.now()}.yaml`);
      fs.writeFileSync(tempFile, yamlContent);
      
      log('green', `‚úÖ Generated YAML test file: ${tempFile}`);
      log('cyan', '\nGenerated test steps:');
      console.log(yamlContent);
      
      return tempFile;
    } else {
      throw new Error('Invalid response from proxy /input endpoint');
    }
  } catch (error) {
    log('red', `‚ùå Failed to generate YAML: ${error.message}`);
    if (error.response) {
      log('yellow', `   Response status: ${error.response.status}`);
      log('yellow', `   Response data: ${JSON.stringify(error.response.data)}`);
    }
    throw error;
  }
}

async function startTestUI(options) {
  log('cyan', '\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  log('cyan', '‚ïë  TestUI - AI Agent Test Execution         ‚ïë');
  log('cyan', '‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  
  // Validate API key
  if (!process.env.ANTHROPIC_API_KEY && !process.env.API_KEY) {
    log('red', '‚ùå ANTHROPIC_API_KEY environment variable not set!');
    log('yellow', '\nüìù Set your API key:');
    log('cyan', '   export ANTHROPIC_API_KEY="your-api-key"\n');
    process.exit(1);
  }
  
  let proxyServer;
  let generatedTestFile = null;
  
  // Determine proxy port (allow override via environment)
  const proxyPort = parseInt(process.env.TESTUI_PROXY_PORT || process.env.PORT || '9876');
  
  try {
    // Start proxy server
    log('cyan', `1Ô∏è‚É£  Starting proxy server (port ${proxyPort})...`);
    proxyServer = spawn('node', [SERVER_SCRIPT], {
      cwd: INSTALL_DIR,
      env: { 
        ...process.env, 
        PORT: String(proxyPort),
        ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY || process.env.API_KEY
      },
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    await new Promise(resolve => setTimeout(resolve, 3000));
  
    const proxyReady = await checkPort(proxyPort);
    if (!proxyReady) {
      log('red', `‚ùå Failed to start proxy server on port ${proxyPort}`);
      log('yellow', `   Port ${proxyPort} might be in use. Try TESTUI_PROXY_PORT=<other-port>`);
      proxyServer.kill();
      process.exit(1);
    }
    log('green', `‚úÖ Proxy server ready at http://localhost:${proxyPort}`);
    
    // Set TD_API_ROOT to proxy server URL for AI decision endpoints
    // Note: The proxy handles /api/v1/testdriver/* endpoints for AI calls
    const tdApiRoot = `http://localhost:${proxyPort}`;
    process.env.TD_API_ROOT = tdApiRoot;
    log('blue', `üîó TD_API_ROOT ‚Üí ${tdApiRoot} (AI endpoints only)\n`);
    
    // Determine test execution method
    let testFilePath;
    
    if (options.testFile && options.prompt) {
      // File + prompt: upgrade/enhance existing YAML
      log('cyan', `2Ô∏è‚É£  ${options.isUpgrade ? 'Upgrading' : 'Enhancing'} existing YAML with prompt...\n`);
      testFilePath = await generateYAMLFromPrompt(options.prompt, proxyPort, options.testFile, options.isUpgrade);
      generatedTestFile = testFilePath;
    } else if (options.testFile) {
      // File only: direct execution
      log('cyan', `2Ô∏è‚É£  Running test from file: ${options.testFile}\n`);
      testFilePath = options.testFile;
    } else if (options.prompt) {
      // Prompt only: generate and run
      log('cyan', '2Ô∏è‚É£  Processing natural language prompt...\n');
      testFilePath = await generateYAMLFromPrompt(options.prompt, proxyPort);
      generatedTestFile = testFilePath;
    } else {
      log('red', '‚ùå No test specified! Provide a prompt or file path.');
      log('yellow', '   Run: testui --help for usage examples\n');
      proxyServer.kill();
      process.exit(1);
    }
    
    log('blue', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
    log('cyan', `\n3Ô∏è‚É£  Executing test: ${path.basename(testFilePath)}\n`);
    log('blue', '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n');
    
    // Run testdriverai with the YAML file
    const testDriver = spawn('npx', ['--yes', 'testdriverai@latest', 'run', testFilePath], {
      env: { 
        ...process.env,
        TD_API_ROOT: tdApiRoot,
        // Don't pass ANTHROPIC_API_KEY - TestDriver will use TD_API_ROOT for AI
        ANTHROPIC_API_KEY: undefined
      },
      stdio: 'inherit'
    });
    
    testDriver.on('exit', (code) => {
      log('blue', '\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
      log('yellow', '\nüßπ Cleaning up...');
      proxyServer.kill();
      
      // Clean up generated test file
      if (generatedTestFile && fs.existsSync(generatedTestFile)) {
        try {
          fs.unlinkSync(generatedTestFile);
          log('cyan', `   Removed temp file: ${path.basename(generatedTestFile)}`);
        } catch (e) {
          // Ignore cleanup errors
        }
      }
      
      if (code === 0) {
        log('green', '\n‚úÖ Test completed successfully!\n');
      } else {
        log('red', '\n‚ùå Test failed with exit code: ' + code + '\n');
      }
      process.exit(code);
    });
    
    // Handle cleanup on interrupt
    process.on('SIGINT', () => {
      log('yellow', '\n\n‚ö†Ô∏è  Interrupted! Cleaning up...');
      proxyServer.kill();
      if (generatedTestFile && fs.existsSync(generatedTestFile)) {
        try {
          fs.unlinkSync(generatedTestFile);
        } catch (e) {
          // Ignore
        }
      }
      process.exit(130);
    });
    
  } catch (error) {
    log('red', '\n‚ùå Error: ' + error.message);
    if (error.stack) log('yellow', error.stack);
    if (proxyServer) proxyServer.kill();
    if (generatedTestFile && fs.existsSync(generatedTestFile)) {
      try {
        fs.unlinkSync(generatedTestFile);
      } catch (e) {
        // Ignore
      }
    }
    process.exit(1);
  }
}

// Main execution
const args = parseArgs();

if (process.argv.length < 3 || process.argv.includes('--help') || process.argv.includes('-h')) {
  showHelp();
}

if (!args.prompt && !args.testFile) {
  log('red', '\n‚ùå No test specified!');
  log('yellow', '\nProvide either:');
  log('cyan', '  PROMPT="natural language test"');
  log('cyan', '  TEST="path/to/test.yaml"\n');
  log('yellow', 'Run with --help for more info\n');
  process.exit(1);
}

startTestUI(args).catch(err => {
  log('red', '\n‚ùå Error: ' + err.message);
  log('red', err.stack);
  process.exit(1);
});
